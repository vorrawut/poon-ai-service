---
alwaysApply: true
---
ğŸ Python Microservice Development Rules & Project Structure
ğŸ—ï¸ Directory Layout (Service-Level)

Each service is self-contained but follows the same layout:

service_name/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ service_name/            # Main application package
â”‚   â”‚   â”œâ”€â”€ api/                 # FastAPI/Flask/Django views/controllers
â”‚   â”‚   â”œâ”€â”€ models/              # Pydantic schemas & ORM entities
â”‚   â”‚   â”œâ”€â”€ services/            # Business logic (pure functions if possible)
â”‚   â”‚   â”œâ”€â”€ repositories/        # Data access (DB, cache, external services)
â”‚   â”‚   â”œâ”€â”€ events/              # Kafka/NATS/PubSub consumers & producers
â”‚   â”‚   â”œâ”€â”€ core/                # Infra: db, cache, auth, config, errors
â”‚   â”‚   â”œâ”€â”€ common/              # Shared utils (logging, middleware)
â”‚   â”‚   â””â”€â”€ __init__.py
â”‚   â””â”€â”€ main.py                  # Service entrypoint
â”œâ”€â”€ tests/                       # Unit & integration tests
â”‚   â”œâ”€â”€ conftest.py
â”‚   â””â”€â”€ features/
â”œâ”€â”€ bruno/                       # Bruno API collections for this service
â”‚   â”œâ”€â”€ collections/
â”‚   â””â”€â”€ environments/
â”œâ”€â”€ docs/                        # Documentation
â”‚   â”œâ”€â”€ puml/                   # PlantUML architecture & sequence diagrams
â”‚   â””â”€â”€ openapi.json             # Exported OpenAPI spec (must be synced)
â”œâ”€â”€ scripts/                     # DevOps & helper scripts
â”œâ”€â”€ Dockerfile                   # Container definition
â”œâ”€â”€ pyproject.toml               # Build & dependency config
â”œâ”€â”€ requirements.txt             # Pinned deps (if lock needed)
â””â”€â”€ README.md


ğŸ”‘ Rules:

Each service owns its data & APIs (no cross-service DB calls).

Bruno tests (/bruno) must be updated with every API change.

Architecture diagrams (/docs/puml) must reflect service-level flows.

Services must stay independent (deployable, testable, observable on their own).

ğŸ“¦ Code Structure (Inside Each Service)
1. api/

Defines request/response contracts (FastAPI routes, Flask blueprints, etc.)

Input validation via Pydantic

Converts transport â†’ domain model

2. models/

Domain entities & schemas

SQLAlchemy/Pydantic models only

Rule: No business logic here

3. services/

Pure business logic

Calls repositories/events, orchestrates flows

Unit tested in isolation

4. repositories/

DB & cache access, external service clients

Each repository handles a single external dependency

Rule: No business logic inside repositories

5. events/

Kafka/PubSub/NATS producers & consumers

Event schema defined here

Tests must validate serialization

6. core/

Infrastructure: config, logging, DB init, error handling

Rule: No domain-specific code here

7. common/

Shared helpers within the service (e.g. response formatter, retry utils)

Rule: Never depend on other servicesâ€™ common/

ğŸ§ª Testing Strategy
1. Unit Tests (/tests/features/)

Mirror src/service_name structure

Test services, repositories, events in isolation

Mocks for external dependencies

2. Integration Tests

Spin up DB/cache locally with Docker (via pytest fixtures)

Cover repository + API contracts

3. API Tests (Bruno)

Live in /bruno

Required for all endpoints before merge

Must be updated when API changes

4. Contract Tests

Ensure producer/consumer events follow agreed schema

Validate against shared schema repo (if exists)

ğŸ“‹ Build & Quality Rules

Code style â†’ ruff (or black if you prefer formatting only)

Type checking â†’ mypy (mandatory for services & models)

Linting â†’ fail CI on errors

Tests â†’ pytest --cov must pass before merge

API contracts â†’ update Bruno & export OpenAPI spec to /docs

ğŸš€ CI/CD Workflow (Mandatory Checks)

Pre-commit hooks

Run ruff, mypy, and pytest -q

Block commit if failed

CI pipeline

Install deps (poetry install or pip)

Run unit + integration tests

Validate Bruno collections against local service

Export OpenAPI spec & validate docs consistency

CD pipeline

Build & push Docker image

Run smoke tests (health check, key endpoints)

Deploy via Helm/K8s

ğŸ”’ Security & Observability

Secrets â†’ env vars only (use Vault or Secret Manager in prod)

Auth â†’ implement in core/middleware (JWT/OAuth2)

Logging â†’ JSON structured logs (logfmt)

Tracing â†’ OpenTelemetry instrumentation required

Metrics â†’ Prometheus/Grafana exporters (per service)

Error handling â†’ centralized in core/errors

ğŸ“ Example Microservice Layout
payments-service/
â”œâ”€â”€ src/payments/
â”‚   â”œâ”€â”€ api/             # FastAPI routes: POST /charge, GET /status
â”‚   â”œâ”€â”€ models/          # ChargeRequest, ChargeResponse, PaymentRecord
â”‚   â”œâ”€â”€ services/        # PaymentService (business rules)
â”‚   â”œâ”€â”€ repositories/    # PaymentRepo (DB), GatewayClient (external API)
â”‚   â”œâ”€â”€ events/          # Kafka consumers/producers
â”‚   â”œâ”€â”€ core/            # db.py, config.py, errors.py, logging.py
â”‚   â”œâ”€â”€ common/          # small helpers
â”‚   â””â”€â”€ __init__.py
â”œâ”€â”€ tests/               # pytest unit & integration
â”œâ”€â”€ bruno/               # Bruno tests for /charge & /status
â”œâ”€â”€ docs/puml/           # Sequence diagrams for payment flows
â”œâ”€â”€ Dockerfile
â””â”€â”€ pyproject.toml


âš¡ This setup reflects best practices for Python microservices:

Clear service boundaries

Clean architecture separation (api â†’ service â†’ repository â†’ infra)

Testing discipline (unit + integration + Bruno + contracts)

Observability & CI/CD baked in

Docs & API tests required for every change