---
alwaysApply: true
---

# 🐍 Python Microservice Development Rules & Standards - Updated 2025

## 🎯 Core Principles

### 1. **Domain-Driven Design (DDD)**
- Each service owns a single business domain/bounded context
- Use ubiquitous language throughout the codebase
- Domain models should reflect business concepts, not database tables
- Aggregate roots control consistency boundaries

### 2. **Clean Architecture**
- Dependencies point inward (Infrastructure → Application → Domain)
- Business logic is framework-agnostic
- External concerns (DB, HTTP, messaging) are pluggable
- High cohesion within layers, loose coupling between layers

### 3. **Service Independence**
- Each service is deployable, testable, and observable independently
- No shared databases between services
- Communicate via well-defined APIs and events
- Own your data, own your destiny

## 🏗️ Enhanced Project Structure (Based on Current Implementation)

```
service_name/
├── src/
│   ├── service_name/
│   │   ├── api/                    # 🌐 HTTP Interface Layer
│   │   │   ├── v1/                 # API versioning
│   │   │   │   ├── routes/         # FastAPI route definitions
│   │   │   │   ├── schemas/        # Request/Response models (Pydantic)
│   │   │   │   └── dependencies/   # Dependency injection
│   │   │   ├── middleware/         # Custom middleware (logging, metrics, errors)
│   │   │   └── exceptions/         # API exception handlers
│   │   ├── domain/                 # 🧠 Business Logic (Core)
│   │   │   ├── entities/           # Domain entities (aggregate roots)
│   │   │   ├── value_objects/      # Immutable value types
│   │   │   ├── aggregates/         # Aggregate roots (if separate from entities)
│   │   │   ├── services/           # Domain services
│   │   │   ├── repositories/       # Repository interfaces (not implementations)
│   │   │   └── events/             # Domain events
│   │   ├── application/            # 🎯 Use Cases & Application Services
│   │   │   ├── commands/           # Command handlers (CQRS)
│   │   │   ├── queries/            # Query handlers (CQRS)
│   │   │   ├── services/           # Application services
│   │   │   └── dto/                # Data Transfer Objects
│   │   ├── infrastructure/         # 🔧 External Concerns
│   │   │   ├── database/           # DB implementations (SQLite, PostgreSQL)
│   │   │   ├── messaging/          # Event bus, Kafka, RabbitMQ
│   │   │   ├── external_apis/      # Third-party API clients (Llama, OCR)
│   │   │   ├── cache/              # Redis, Memcached
│   │   │   └── storage/            # File storage, S3
│   │   ├── core/                   # 🛠️ Cross-cutting Concerns
│   │   │   ├── config/             # Configuration management (Pydantic Settings)
│   │   │   ├── logging/            # Structured logging (structlog)
│   │   │   ├── security/           # Auth, encryption
│   │   │   ├── monitoring/         # Metrics, health checks (Prometheus)
│   │   │   ├── errors/             # Custom exceptions
│   │   │   └── utils/              # Generic utilities
│   │   └── __init__.py
│   └── main.py                     # 🚀 Application entrypoint
├── tests/                          # 🧪 Comprehensive Test Suite
│   ├── unit/                       # Fast, isolated tests
│   ├── integration/                # Service integration tests
│   ├── e2e/                        # End-to-end scenarios
│   ├── fixtures/                   # Test data and factories
│   └── conftest.py                 # Pytest configuration
├── bruno/                          # 📡 API Testing & Documentation
├── docs/                           # 📚 Documentation
├── scripts/                        # 🛠️ Automation Scripts
├── docker/                         # 🐳 Container Configuration
├── pyproject.toml                  # 📦 Project Configuration
├── .env.example                    # 🔐 Environment Template
├── Makefile                        # 🔧 Development Commands
└── README.md                       # 📖 Project Documentation
```

## 📋 Layer Responsibilities (Updated Based on Analysis)

### 🌐 **API Layer** (`api/`)
- **Purpose**: HTTP interface and transport concerns
- **Rules**:
  - Only handle HTTP-specific logic (routing, serialization, auth)
  - Validate input using Pydantic models
  - Transform DTOs ↔ Domain models
  - Handle HTTP status codes and responses
  - Never contain business logic
  - Use FastAPI dependency injection for services
- **Dependencies**: Application layer only
- **Current Implementation**: ✅ Well-structured with middleware, versioning, and proper separation

### 🧠 **Domain Layer** (`domain/`)
- **Purpose**: Core business logic and rules
- **Rules**:
  - Framework-agnostic pure Python
  - Contains business invariants and validation
  - Defines repository interfaces (not implementations)
  - Emits domain events for side effects
  - No external dependencies (DB, HTTP, etc.)
  - Use immutable value objects with proper validation
  - Implement rich domain entities with business methods
- **Dependencies**: None (pure business logic)
- **Current Implementation**: ✅ Excellent value objects, proper entity design, clean interfaces

### 🎯 **Application Layer** (`application/`)
- **Purpose**: Use cases and application workflows
- **Rules**:
  - Orchestrates domain objects
  - Handles cross-cutting concerns (transactions, events)
  - Implements CQRS pattern (commands/queries)
  - Coordinates multiple repositories
  - Maps between domain and DTOs
  - Command/Query handlers should be stateless
- **Dependencies**: Domain layer only
- **Current Implementation**: ✅ Good CQRS implementation, proper command/query separation

### 🔧 **Infrastructure Layer** (`infrastructure/`)
- **Purpose**: External system implementations
- **Rules**:
  - Implements domain repository interfaces
  - Handles database, messaging, external APIs
  - Contains framework-specific code
  - Manages connection pooling, retries, timeouts
  - No business logic allowed
  - Proper error handling and logging
- **Dependencies**: Domain and Application layers
- **Current Implementation**: ✅ Clean implementations for SQLite, Llama, OCR clients

## 🧪 Testing Strategy (Enhanced Based on Current State)

### **Test Pyramid Structure**
```
           /\
          /  \    🔺 E2E Tests (Few, Slow, Expensive)
         /____\
        /      \  🔶 Integration Tests (Some, Medium)
       /________\
      /          \ 🔻 Unit Tests (Many, Fast, Cheap)
     /____________\
```

### **Current Test Coverage Analysis**
- **Total Source Files**: 42 Python files
- **Total Test Files**: 9 test files
- **Test Coverage**: ~21% file coverage (needs improvement)
- **Test Types**: Unit (5), Integration (3), E2E (1)
- **Coverage Target**: 80% (configured in pyproject.toml)

### **Testing Guidelines (Updated)**
- **Unit Tests**: 90%+ coverage for domain/application layers
- **Integration Tests**: Repository implementations, API endpoints
- **E2E Tests**: Critical user journeys only
- **Contract Tests**: API compatibility between services
- **Test Markers**: Use `@pytest.mark.unit`, `@pytest.mark.integration`, `@pytest.mark.e2e`
- **Test Structure**: Follow AAA pattern (Arrange, Act, Assert)

### **Value Object Testing Pattern**
```python
@pytest.mark.unit
class TestMoney:
    """Unit tests for Money value object."""

    def test_creation_success(self):
        """Test successful money creation."""
        money = Money.from_float(100.50, Currency.USD)
        assert money.amount == Decimal("100.50")
        assert money.currency == Currency.USD

    def test_negative_amount_raises_error(self):
        """Test negative amount validation."""
        with pytest.raises(ValueError, match="Money amount cannot be negative"):
            Money(amount=Decimal("-10"), currency=Currency.USD)

    def test_currency_validation(self):
        """Test currency addition validation."""
        usd_money = Money.from_float(100, Currency.USD)
        thb_money = Money.from_float(100, Currency.THB)

        with pytest.raises(ValueError, match="Cannot add different currencies"):
            usd_money.add(thb_money)
```

## 🔍 Code Quality Standards (Enhanced)

### **Linting & Formatting (Current Configuration)**
```toml
# pyproject.toml - Current excellent configuration
[tool.ruff]
target-version = "py311"
line-length = 88
select = [
    "E", "W",   # pycodestyle
    "F",        # pyflakes
    "I",        # isort
    "B",        # flake8-bugbear
    "C4",       # flake8-comprehensions
    "UP",       # pyupgrade
    "N",        # pep8-naming
    "S",        # flake8-bandit (security)
    "RUF",      # Ruff-specific rules
    "PT",       # flake8-pytest-style
    "SIM",      # flake8-simplify
    "TCH",      # flake8-type-checking
    "ARG",      # flake8-unused-arguments
    "ERA",      # eradicate (commented-out code)
]

[tool.mypy]
python_version = "3.11"
strict = true
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true
```

### **Type Checking Requirements (Enhanced)**
- 100% type coverage for public APIs ✅ (Current implementation excellent)
- Use typing.Protocol for interfaces ✅
- Leverage generics for reusable code ✅
- Complete type annotations required ✅
- Use `from __future__ import annotations` for forward references ✅

### **Value Object Design Patterns (Based on Current Implementation)**
```python
@dataclass(frozen=True)
class Money:
    """Immutable money value object with proper validation."""
    amount: Decimal
    currency: Currency

    def __post_init__(self) -> None:
        """Validate constraints."""
        if self.amount < 0:
            raise ValueError("Money amount cannot be negative")

    @classmethod
    def from_float(cls, amount: float, currency: Currency) -> Money:
        """Factory method for float conversion."""
        return cls(amount=Decimal(str(amount)), currency=currency)

    def add(self, other: Money) -> Money:
        """Business operation with validation."""
        if self.currency != other.currency:
            raise ValueError("Cannot add different currencies")
        return Money(amount=self.amount + other.amount, currency=self.currency)
```

## 🚀 Development Workflow (Enhanced)

### **Dependency Management (Current: Poetry)**
```toml
[tool.poetry.dependencies]
python = "^3.11"
fastapi = "^0.116.1"
pydantic = "^2.5.0"
pydantic-settings = "^2.1.0"
structlog = "^23.2.0"
prometheus-client = "^0.19.0"

[tool.poetry.group.dev.dependencies]
pytest = "^7.4.0"
pytest-cov = "^4.1.0"
ruff = "^0.1.0"
mypy = "^1.5.1"
pre-commit = "^3.5.0"
```

### **Service Registry Pattern (Current Implementation)**
```python
class ServiceRegistry:
    """Service registry for dependency injection."""

    def __init__(self) -> None:
        self.spending_repository: SqliteSpendingRepository | None = None
        self.llama_client: LlamaClient | None = None
        self.ocr_client: TesseractOCRClient | None = None

    async def initialize(self) -> None:
        """Initialize all services with proper error handling."""
        # Initialize services with health checks
        # Store in app.state for FastAPI dependency injection
```

### **Configuration Management (Current: Pydantic Settings)**
```python
class Settings(BaseSettings):
    """Type-safe configuration with validation."""
    model_config = SettingsConfigDict(
        env_file=".env",
        case_sensitive=False,
        extra="ignore"
    )

    # Application settings with defaults and validation
    app_name: str = Field(default="Poon AI Service")
    debug: bool = Field(default=False)
    database_url: str = Field(default="sqlite:///./spending.db")
```

### **Development Commands (Makefile)**
```bash
# Setup
make setup-dev
make install-deps

# Code Quality
make lint
make type-check
make format

# Testing
make test
make test-unit
make test-integration
make test-coverage

# Development Server
make run-dev
make run-debug
```

## 🔒 Security & Observability (Enhanced)

### **Structured Logging (Current: structlog)**
```python
import structlog
logger = structlog.get_logger(__name__)

# Usage
logger.info("User action", user_id=123, action="login", extra_context={})
logger.error("Processing failed", error=str(e), entry_id=entry.id.value)
```

### **Metrics Collection (Current: Prometheus)**
```python
from prometheus_client import Counter, Histogram

REQUEST_COUNT = Counter('http_requests_total', 'Total requests')
REQUEST_DURATION = Histogram('http_request_duration_seconds', 'Request duration')

# Usage in middleware
REQUEST_COUNT.inc()
REQUEST_DURATION.observe(duration)
```

### **Health Checks (Current Implementation)**
```python
@app.get("/health")
async def health_check() -> dict:
    return {
        "status": "healthy",
        "service": settings.app_name,
        "version": settings.app_version,
        "environment": settings.environment,
    }

@app.get("/api/v1/health/detailed")
async def detailed_health_check() -> dict:
    return {
        "status": "healthy",
        "dependencies": {
            "database": await check_database(),
            "llama": await check_llama_service(),
            "ocr": await check_ocr_service(),
        },
        "features": {
            "ai_enhancement": settings.use_llama,
            "ocr_processing": ocr_client.is_available(),
        }
    }
```

### **Dependency Injection Patterns (Current Implementation)**
```python
# In main.py
app.state.spending_repository = service_registry.spending_repository
app.state.llama_client = service_registry.llama_client

# In routes
async def get_repository(request: Request) -> SpendingRepository:
    return request.app.state.spending_repository

# Usage
@router.get("/spending/")
async def get_spending_entries(
    repository: SpendingRepository = Depends(get_repository)
) -> dict:
    # Use repository
```

## 📈 Performance Guidelines (Enhanced)

### **Async/Await Best Practices (Current Implementation)**
```python
# Proper async repository pattern
class SqliteSpendingRepository(SpendingRepository):
    async def save(self, entry: SpendingEntry) -> None:
        async with self._connection.execute(...) as cursor:
            # Database operations

    async def find_by_id(self, entry_id: SpendingEntryId) -> SpendingEntry | None:
        # Async query operations
```

### **Connection Management**
```python
# Proper connection lifecycle
async def initialize(self) -> None:
    self._connection = await aiosqlite.connect(self.database_url)
    self._connection.row_factory = aiosqlite.Row

async def close(self) -> None:
    if self._connection:
        await self._connection.close()
```

### **Command/Query Handler Patterns**
```python
class ProcessTextCommandHandler(CommandHandler[ProcessTextCommand, CommandResult]):
    def __init__(
        self,
        repository: SpendingRepository,
        text_processing_service: Any,
    ) -> None:
        self._repository = repository
        self._text_processing_service = text_processing_service

    async def handle(self, command: ProcessTextCommand) -> CommandResult:
        try:
            command.validate()
            # Business logic
            return CommandResult.success_result(...)
        except Exception as e:
            return CommandResult.failure_result(...)
```

## 🐳 Containerization (Enhanced)

### **Multi-stage Dockerfile (Recommended)**
```dockerfile
FROM python:3.11-slim as base
WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    tesseract-ocr \
    tesseract-ocr-eng \
    tesseract-ocr-tha \
    && rm -rf /var/lib/apt/lists/*

# Install Poetry
RUN pip install poetry
COPY pyproject.toml poetry.lock ./
RUN poetry config virtualenvs.create false

FROM base as development
RUN poetry install
COPY . .
CMD ["uvicorn", "main:app", "--reload", "--host", "0.0.0.0"]

FROM base as production
RUN poetry install --only=main --no-dev
COPY src/ ./src/
COPY main.py ./
USER 1000
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

## 🔄 Event-Driven Architecture (Enhanced)

### **Domain Events (Current Implementation)**
```python
@dataclass(frozen=True)
class DomainEvent(ABC):
    event_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    occurred_at: datetime = field(default_factory=datetime.utcnow)
    event_version: int = field(default=1)

    @property
    @abstractmethod
    def event_type(self) -> str:
        pass

    @abstractmethod
    def get_event_data(self) -> dict[str, Any]:
        pass
```

### **Event Handling Pattern**
```python
# Domain entity with events
@dataclass
class SpendingEntry:
    # Domain events
    _events: list[Any] = field(default_factory=list, init=False)

    def add_event(self, event: DomainEvent) -> None:
        self._events.append(event)

    def clear_events(self) -> list[DomainEvent]:
        events = self._events.copy()
        self._events.clear()
        return events
```

## 🎯 Best Practices Checklist (Updated)

### **Code Quality** ✅ Current Status
- [x] All public APIs have type hints
- [x] All functions have docstrings
- [x] No business logic in API layer
- [x] Repository pattern for data access
- [x] Domain events infrastructure ready
- [x] Proper error handling and logging
- [x] Input validation at boundaries

### **Testing** ⚠️ Needs Improvement
- [x] Unit tests for core business logic
- [ ] Integration tests for all repositories (partial)
- [ ] API tests for all endpoints (partial)
- [ ] Test coverage > 90% (currently ~80% target)
- [x] Tests run quickly
- [x] No flaky tests

### **Security** ✅ Current Status
- [x] Input validation on all endpoints
- [ ] Authentication on protected routes (not implemented)
- [ ] Authorization checks implemented (not needed yet)
- [x] Secrets in environment variables
- [x] SQL injection prevention (parameterized queries)
- [ ] Rate limiting configured (not implemented)

### **Observability** ✅ Current Status
- [x] Structured logging implemented
- [x] Metrics collection active
- [ ] Distributed tracing enabled (not implemented)
- [x] Health checks available
- [x] Error monitoring configured
- [x] Performance monitoring active

### **Documentation** ⚠️ Needs Improvement
- [x] README with setup instructions
- [ ] API documentation generated (partial)
- [ ] Architecture diagrams updated (needs update)
- [ ] Runbooks for operations (missing)
- [ ] Changelog maintained (missing)
- [x] Bruno tests updated

## 🚨 Anti-Patterns to Avoid (Based on Analysis)

### **Architectural Anti-Patterns**
- ❌ **God Services**: Services that do everything
- ❌ **Chatty Interfaces**: Too many small API calls
- ❌ **Shared Databases**: Multiple services accessing same DB
- ❌ **Distributed Monolith**: Services too tightly coupled
- ❌ **Data Inconsistency**: Not handling eventual consistency

### **Code Anti-Patterns (Observed)**
- ❌ **Anemic Domain Models**: Models with only getters/setters
- ❌ **Transaction Script**: All logic in service methods
- ❌ **Magic Numbers**: Hardcoded values without constants
- ❌ **Long Parameter Lists**: Methods with too many parameters
- ❌ **Feature Envy**: Classes using other classes' data too much

### **Testing Anti-Patterns**
- ❌ **Test Interdependence**: Tests that depend on each other
- ❌ **Slow Tests**: Test suite takes > 10 minutes
- ❌ **Flaky Tests**: Tests that sometimes fail randomly
- ❌ **Testing Implementation**: Testing private methods
- ❌ **Mock Heavy**: Mocking everything including value objects

## 🎉 Success Metrics (Current Implementation)

### **Development Velocity**
- Feature delivery time: Fast (good architecture support)
- Bug fix time: Quick (good separation of concerns)
- Code review cycle time: Efficient (clear patterns)
- Deployment frequency: Ready for CI/CD

### **Quality Metrics**
- Test coverage percentage: 80% target (needs improvement)
- Bug escape rate: Low (good type safety)
- Technical debt ratio: Low (clean architecture)
- Code complexity scores: Good (proper separation)

### **Operational Metrics**
- Service availability: 99.9%+ target
- Response time: p95 < 200ms target
- Error rate: < 0.1% target
- Recovery time: < 5 minutes target

## 🔧 Recommended Improvements (Based on Analysis)

### **Immediate Actions**
1. **Increase Test Coverage**: Add more unit tests for value objects and entities
2. **Complete Integration Tests**: Test all repository implementations thoroughly
3. **Add Authentication**: Implement JWT-based authentication if needed
4. **Performance Testing**: Add benchmarks for critical paths
5. **Documentation**: Complete API documentation with examples

### **Medium-term Improvements**
1. **Distributed Tracing**: Add OpenTelemetry for request tracing
2. **Rate Limiting**: Implement rate limiting for public APIs
3. **Caching Strategy**: Add Redis caching for frequent queries
4. **Event Sourcing**: Complete domain events implementation
5. **Monitoring Dashboards**: Create Grafana dashboards for metrics

---

**Remember**: These rules are guidelines based on the current implementation analysis. Adapt them to your specific context while maintaining the core principles of clean architecture, testability, and maintainability. The current codebase shows excellent adherence to clean architecture principles with room for improvement in testing coverage and operational concerns.
