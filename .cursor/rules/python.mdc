---
alwaysApply: true
---

# ğŸ Python Microservice Development Rules & Standards

## ğŸ¯ Core Principles

### 1. **Domain-Driven Design (DDD)**
- Each service owns a single business domain/bounded context
- Use ubiquitous language throughout the codebase
- Domain models should reflect business concepts, not database tables
- Aggregate roots control consistency boundaries

### 2. **Clean Architecture**
- Dependencies point inward (Infrastructure â†’ Application â†’ Domain)
- Business logic is framework-agnostic
- External concerns (DB, HTTP, messaging) are pluggable
- High cohesion within layers, loose coupling between layers

### 3. **Service Independence**
- Each service is deployable, testable, and observable independently
- No shared databases between services
- Communicate via well-defined APIs and events
- Own your data, own your destiny

## ğŸ—ï¸ Enhanced Project Structure

```
service_name/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ service_name/
â”‚   â”‚   â”œâ”€â”€ api/                    # ğŸŒ HTTP Interface Layer
â”‚   â”‚   â”‚   â”œâ”€â”€ v1/                 # API versioning
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ routes/         # FastAPI route definitions
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ schemas/        # Request/Response models
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ dependencies/   # Dependency injection
â”‚   â”‚   â”‚   â”œâ”€â”€ middleware/         # Custom middleware
â”‚   â”‚   â”‚   â””â”€â”€ exceptions/         # API exception handlers
â”‚   â”‚   â”œâ”€â”€ domain/                 # ğŸ§  Business Logic (Core)
â”‚   â”‚   â”‚   â”œâ”€â”€ entities/           # Domain entities
â”‚   â”‚   â”‚   â”œâ”€â”€ value_objects/      # Immutable value types
â”‚   â”‚   â”‚   â”œâ”€â”€ aggregates/         # Aggregate roots
â”‚   â”‚   â”‚   â”œâ”€â”€ services/           # Domain services
â”‚   â”‚   â”‚   â”œâ”€â”€ repositories/       # Repository interfaces
â”‚   â”‚   â”‚   â””â”€â”€ events/             # Domain events
â”‚   â”‚   â”œâ”€â”€ application/            # ğŸ¯ Use Cases & Application Services
â”‚   â”‚   â”‚   â”œâ”€â”€ commands/           # Command handlers (CQRS)
â”‚   â”‚   â”‚   â”œâ”€â”€ queries/            # Query handlers (CQRS)
â”‚   â”‚   â”‚   â”œâ”€â”€ services/           # Application services
â”‚   â”‚   â”‚   â””â”€â”€ dto/                # Data Transfer Objects
â”‚   â”‚   â”œâ”€â”€ infrastructure/         # ğŸ”§ External Concerns
â”‚   â”‚   â”‚   â”œâ”€â”€ database/           # DB implementations
â”‚   â”‚   â”‚   â”œâ”€â”€ messaging/          # Event bus, Kafka, RabbitMQ
â”‚   â”‚   â”‚   â”œâ”€â”€ external_apis/      # Third-party API clients
â”‚   â”‚   â”‚   â”œâ”€â”€ cache/              # Redis, Memcached
â”‚   â”‚   â”‚   â””â”€â”€ storage/            # File storage, S3
â”‚   â”‚   â”œâ”€â”€ core/                   # ğŸ› ï¸ Cross-cutting Concerns
â”‚   â”‚   â”‚   â”œâ”€â”€ config/             # Configuration management
â”‚   â”‚   â”‚   â”œâ”€â”€ logging/            # Structured logging
â”‚   â”‚   â”‚   â”œâ”€â”€ security/           # Auth, encryption
â”‚   â”‚   â”‚   â”œâ”€â”€ monitoring/         # Metrics, health checks
â”‚   â”‚   â”‚   â”œâ”€â”€ errors/             # Custom exceptions
â”‚   â”‚   â”‚   â””â”€â”€ utils/              # Generic utilities
â”‚   â”‚   â””â”€â”€ __init__.py
â”‚   â””â”€â”€ main.py                     # ğŸš€ Application entrypoint
â”œâ”€â”€ tests/                          # ğŸ§ª Comprehensive Test Suite
â”‚   â”œâ”€â”€ unit/                       # Fast, isolated tests
â”‚   â”œâ”€â”€ integration/                # Service integration tests
â”‚   â”œâ”€â”€ e2e/                        # End-to-end scenarios
â”‚   â”œâ”€â”€ fixtures/                   # Test data and factories
â”‚   â””â”€â”€ conftest.py                 # Pytest configuration
â”œâ”€â”€ bruno/                          # ğŸ“¡ API Testing & Documentation
â”œâ”€â”€ docs/                           # ğŸ“š Documentation
â”œâ”€â”€ scripts/                        # ğŸ› ï¸ Automation Scripts
â”œâ”€â”€ .github/                        # ğŸ”„ CI/CD Configuration
â”œâ”€â”€ docker/                         # ğŸ³ Container Configuration
â”œâ”€â”€ pyproject.toml                  # ğŸ“¦ Project Configuration
â”œâ”€â”€ poetry.lock                     # ğŸ”’ Dependency Lock File
â”œâ”€â”€ .pre-commit-config.yaml         # ğŸ” Pre-commit Hooks
â”œâ”€â”€ .env.example                    # ğŸ” Environment Template
â””â”€â”€ README.md                       # ğŸ“– Project Documentation
```

## ğŸ“‹ Layer Responsibilities

### ğŸŒ **API Layer** (`api/`)
- **Purpose**: HTTP interface and transport concerns
- **Rules**:
  - Only handle HTTP-specific logic (routing, serialization, auth)
  - Validate input using Pydantic models
  - Transform DTOs â†” Domain models
  - Handle HTTP status codes and responses
  - Never contain business logic
- **Dependencies**: Application layer only

### ğŸ§  **Domain Layer** (`domain/`)
- **Purpose**: Core business logic and rules
- **Rules**:
  - Framework-agnostic pure Python
  - Contains business invariants and validation
  - Defines repository interfaces (not implementations)
  - Emits domain events for side effects
  - No external dependencies (DB, HTTP, etc.)
- **Dependencies**: None (pure business logic)

### ğŸ¯ **Application Layer** (`application/`)
- **Purpose**: Use cases and application workflows
- **Rules**:
  - Orchestrates domain objects
  - Handles cross-cutting concerns (transactions, events)
  - Implements CQRS pattern (commands/queries)
  - Coordinates multiple repositories
  - Maps between domain and DTOs
- **Dependencies**: Domain layer only

### ğŸ”§ **Infrastructure Layer** (`infrastructure/`)
- **Purpose**: External system implementations
- **Rules**:
  - Implements domain repository interfaces
  - Handles database, messaging, external APIs
  - Contains framework-specific code
  - Manages connection pooling, retries, timeouts
  - No business logic allowed
- **Dependencies**: Domain and Application layers

## ğŸ§ª Testing Strategy

### **Test Pyramid Structure**
```
           /\
          /  \    ğŸ”º E2E Tests (Few, Slow, Expensive)
         /____\   
        /      \  ğŸ”¶ Integration Tests (Some, Medium)
       /________\ 
      /          \ ğŸ”» Unit Tests (Many, Fast, Cheap)
     /____________\
```

### **Testing Guidelines**
- **Unit Tests**: 90%+ coverage for domain/application layers
- **Integration Tests**: Repository implementations, API endpoints
- **E2E Tests**: Critical user journeys only
- **Contract Tests**: API compatibility between services

## ğŸ” Code Quality Standards

### **Linting & Formatting**
```toml
# pyproject.toml
[tool.ruff]
target-version = "py311"
line-length = 88
select = [
    "E", "W",  # pycodestyle
    "F",       # pyflakes
    "I",       # isort
    "B",       # flake8-bugbear
    "C4",      # flake8-comprehensions
    "UP",      # pyupgrade
    "N",       # pep8-naming
    "S",       # flake8-bandit
]

[tool.mypy]
python_version = "3.11"
strict = true
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true
```

### **Type Checking Requirements**
- 100% type coverage for public APIs
- Use typing.Protocol for interfaces
- Leverage generics for reusable code
- Complete type annotations required

## ğŸš€ Development Workflow

### **Pre-commit Hooks**
```yaml
# .pre-commit-config.yaml
repos:
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.4.0
    hooks:
      - id: trailing-whitespace
      - id: end-of-file-fixer
      - id: check-yaml
      - id: check-json
  
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.1.0
    hooks:
      - id: ruff
        args: [--fix, --exit-non-zero-on-fix]
      - id: ruff-format
  
  - repo: https://github.com/pre-commit/mirrors-mypy
    rev: v1.5.1
    hooks:
      - id: mypy
        additional_dependencies: [types-all]
```

### **CI/CD Pipeline**
1. **Continuous Integration**
   - Install dependencies (Poetry)
   - Run linting (Ruff, MyPy)
   - Execute test suite (pytest with coverage)
   - Security scanning (Bandit, Safety)
   - Build Docker image
   - Generate OpenAPI spec

2. **Continuous Deployment**
   - Deploy to staging environment
   - Run smoke tests
   - Deploy to production (blue-green)
   - Monitor deployment health

## ğŸ”’ Security & Observability

### **Security Standards**
- **Authentication**: JWT with proper validation
- **Authorization**: Role-based access control (RBAC)
- **Input validation**: Pydantic models with constraints
- **Secrets management**: Environment variables only
- **SQL injection**: Use parameterized queries
- **HTTPS**: TLS 1.3 minimum in production

### **Observability Stack**
```python
# Structured logging
import structlog
logger = structlog.get_logger()
logger.info("User action", user_id=123, action="login")

# Metrics
from prometheus_client import Counter, Histogram
REQUEST_COUNT = Counter('http_requests_total', 'Total requests')
REQUEST_DURATION = Histogram('http_request_duration_seconds', 'Request duration')

# Tracing
from opentelemetry import trace
tracer = trace.get_tracer(__name__)
with tracer.start_as_current_span("process_payment") as span:
    span.set_attribute("payment.amount", amount)
```

### **Health Checks**
```python
@app.get("/health")
async def health_check():
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow(),
        "version": app.version,
        "dependencies": {
            "database": await check_database(),
            "redis": await check_redis(),
            "external_api": await check_external_api()
        }
    }
```

## ğŸ“¦ Dependency Management

### **Poetry Configuration**
```toml
[tool.poetry]
name = "service-name"
version = "0.1.0"
description = "Microservice description"
authors = ["Team <team@company.com>"]

[tool.poetry.dependencies]
python = "^3.11"
fastapi = "^0.104.0"
pydantic = "^2.5.0"
sqlalchemy = "^2.0.0"
alembic = "^1.12.0"

[tool.poetry.group.dev.dependencies]
pytest = "^7.4.0"
pytest-cov = "^4.1.0"
pytest-mock = "^3.11.0"
factory-boy = "^3.3.0"
httpx = "^0.25.0"
```

## ğŸ³ Containerization

### **Multi-stage Dockerfile**
```dockerfile
FROM python:3.11-slim as base
WORKDIR /app
RUN pip install poetry
COPY pyproject.toml poetry.lock ./
RUN poetry config virtualenvs.create false
RUN poetry install --only=main --no-dev

FROM base as development
RUN poetry install
COPY . .
CMD ["uvicorn", "main:app", "--reload", "--host", "0.0.0.0"]

FROM base as production
COPY src/ ./src/
COPY main.py ./
USER 1000
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

## ğŸ“ˆ Performance Guidelines

### **Database Optimization**
- Use connection pooling (SQLAlchemy)
- Implement proper indexing strategy
- Use read replicas for queries
- Cache frequently accessed data (Redis)
- Monitor query performance

### **API Performance**
- Implement response caching
- Use async/await for I/O operations
- Implement rate limiting
- Compress responses (gzip)
- Use CDN for static assets

## ğŸ”„ Event-Driven Architecture

### **Domain Events**
```python
from dataclasses import dataclass
from datetime import datetime
from typing import Any, Dict

@dataclass(frozen=True)
class DomainEvent:
    event_id: str
    occurred_at: datetime
    event_type: str
    aggregate_id: str
    event_data: Dict[str, Any]
    version: int = 1

@dataclass(frozen=True)
class UserRegistered(DomainEvent):
    event_type: str = "user.registered"
```

### **Event Handlers**
```python
from typing import Protocol

class EventHandler(Protocol):
    async def handle(self, event: DomainEvent) -> None: ...

class SendWelcomeEmailHandler:
    async def handle(self, event: UserRegistered) -> None:
        # Send welcome email logic
        pass
```

## ğŸ¯ Best Practices Checklist

### **Code Quality**
- [ ] All public APIs have type hints
- [ ] All functions have docstrings
- [ ] No business logic in API layer
- [ ] Repository pattern for data access
- [ ] Domain events for side effects
- [ ] Proper error handling and logging
- [ ] Input validation at boundaries

### **Testing**
- [ ] Unit tests for all business logic
- [ ] Integration tests for repositories
- [ ] API tests for all endpoints
- [ ] Test coverage > 90%
- [ ] Tests run in < 5 minutes
- [ ] No flaky tests

### **Security**
- [ ] Input validation on all endpoints
- [ ] Authentication on protected routes
- [ ] Authorization checks implemented
- [ ] Secrets in environment variables
- [ ] SQL injection prevention
- [ ] Rate limiting configured

### **Observability**
- [ ] Structured logging implemented
- [ ] Metrics collection active
- [ ] Distributed tracing enabled
- [ ] Health checks available
- [ ] Error monitoring configured
- [ ] Performance monitoring active

### **Documentation**
- [ ] README with setup instructions
- [ ] API documentation generated
- [ ] Architecture diagrams updated
- [ ] Runbooks for operations
- [ ] Changelog maintained
- [ ] Bruno tests updated

## ğŸš¨ Anti-Patterns to Avoid

### **Architectural Anti-Patterns**
- âŒ **God Services**: Services that do everything
- âŒ **Chatty Interfaces**: Too many small API calls
- âŒ **Shared Databases**: Multiple services accessing same DB
- âŒ **Distributed Monolith**: Services too tightly coupled
- âŒ **Data Inconsistency**: Not handling eventual consistency

### **Code Anti-Patterns**
- âŒ **Anemic Domain Models**: Models with only getters/setters
- âŒ **Transaction Script**: All logic in service methods
- âŒ **Magic Numbers**: Hardcoded values without constants
- âŒ **Long Parameter Lists**: Methods with too many parameters
- âŒ **Feature Envy**: Classes using other classes' data too much

### **Testing Anti-Patterns**
- âŒ **Test Interdependence**: Tests that depend on each other
- âŒ **Slow Tests**: Test suite takes > 10 minutes
- âŒ **Flaky Tests**: Tests that sometimes fail randomly
- âŒ **Testing Implementation**: Testing private methods
- âŒ **Mock Heavy**: Mocking everything including value objects

## ğŸ‰ Success Metrics

### **Development Velocity**
- Feature delivery time
- Bug fix time
- Code review cycle time
- Deployment frequency

### **Quality Metrics**
- Test coverage percentage
- Bug escape rate
- Technical debt ratio
- Code complexity scores

### **Operational Metrics**
- Service availability (99.9%+)
- Response time (p95 < 200ms)
- Error rate (< 0.1%)
- Recovery time (< 5 minutes)

---

**Remember**: These rules are guidelines, not dogma. Adapt them to your specific context while maintaining the core principles of clean architecture, testability, and maintainability.